#ifndef MUS_BSP_H
#define MUS_BSP_H

#include <stdint.h>

/* Константы для работы с регистром RPTM*/
unsigned int *const r_RPTM = (unsigned int *)0x20500504; // r/w, РПТМ, Регистр программной телеметрии
const unsigned int m_RPTM = 0x000003FF;



unsigned int *const r_RGU = (unsigned int *)0x20500500; // r/w, РГУ, Регистр управления
unsigned int *const r_BUK = (unsigned int *)0x20500510; // r/w, РБУК, Регистр блокировки управления коммутаторами
unsigned int *const r_UKMVP1 = (unsigned int *)0x20500514; // r/w, РУК_МВП1,Регистр управления коммутатором МВП1
unsigned int *const r_UKMVP2 = (unsigned int *)0x20500518; // r/w, РУК_МВП2,Регистр управления коммутатором МВП2

/* Константы для регистров узлов диагностики */
#define vklRUK 0x000FFA5 // код включения коммутатора МВП на регистре РУК_МВП1/РУК_МВП2

#define ASI02 0x02
#define ASI16 0x10
#define ASI17 0x11

/*
   ----------------------------------------------------------------------
   Перечисление USED_ASR
   Назначение.
       Константы, которые используются для выбора необходимого регистра ASR:
       1) ASR16;
       2) ASR17;
       3) ASR18.

       1) Регистр ASR16 (Регистр управления защитой регистра %asr16):

       31   30 29  27 26      18  17    16   15  14 13  11 10      3  2     1    0
       ______________________________________________________________________________
       | FPFT | FCNT | RESERVED | FTE | FDI | IUFT | ICNT | TB[7:0] | DP | ITE | IDI|
       ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

       [31:30]: FP FT ID - определяемый на условиях FPU тип SEU защиты
       [29:27]: количество FCNT ошибок - количество ошибок, обнаруженных в регистре FP.
       [26:18]: сохранение
       [17]:    запуск отладки FPU RF – запускается модуль отладки регистра FPU. Перед записью
                скорректированного бита (ТВ) в регистр FPU производится проверка на четность
                логической операцией «исключающее ИЛИ»
       [16]:    запрет защиты регистров FP (registerRF) – если после установки запрещена защита
                контролем по четности FP RF
       [15:14]: IU FT ID - определяемый на условиях IU тип SEU защиты
       [13:11]: количество IU ошибок - количество ошибок, обнаруженных в регистре IU
       [10:3]:  откорректированные RF биты (FTB) – данные биты в процессе отладки проходят
                проверку на четность логической операцией «исключающее ИЛИ», после чего
                заносятся в регистр
       [2]:     DP ram select (DP) – используется только в IU или FPU, включает 2 парных
                интерфейса ram
       [1]:     запуск отладки IU RF - запускается модуль отладки регистра. Перед записью
                скорректированного бита (ТВ) в регистр FPU производится проверка на четность
                логической операцией «исключающее ИЛИ»
       [0]:     запрет защиты регистров IU RF (IDI) – если после установки запрещена защита
                контролем по четности IU RF

      2) Регистр ASR17 (Регистр конфигурации процессора SoC2012 %asr17)

      31     28 27      18  17  16  15  14   13   12  11 10  9   8   7   5 4    0
       ___________________________________________________________________________
       | INDEX | RESERVED | CS |  CF  | DW | SV | LD | FPU | M | V8 | NWP | NWIN |
       ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
       [31:28]: индекс процессора в мультипроцессорной системе; каждое ядро процессора имеет
                данные о поддержке индексов.
       [17]:    запуск выключателя тактовой частоты. Если произведены соответствующие
                установки, то происходит разблокировка выключателей АНВ и частоты процессора.
       [16:15]: синхронизирующая частота процессора (CF). Ядра процессора работают на частоте
                (CF+1) x AHB ((CF+1) times AHB frequency).
       [14]:    отключение системного прерывания вследствие обнаружения ошибки записи
                (DWT). При заданном значении «0» одно системное прерывание вследствие
                обнаружения ошибки записи (tt=0x2b) будет пропущено. При заданном значении
                «1» системное прерывание вследствие обнаружения ошибки будет разрешено.
                После перезагрузки данный параметр устанавливается в значении «0».
       [13]:    запуск захвата одинарного вектора. При заданном значении «1» происходит запуск
                данного системного прерывания. В случае неиспользования захвата одинарного
                вектора, данный параметр необходимо установить в значении «0». После
                перезагрузки данный параметр устанавливается в значении «0».
       [12]:    задержка загрузки. Если произведены соответствующие установки, то линия потока
                данных использует задержку загрузки в два такта, в противном случае использует
                задержку загрузки в один такт.
       [11:10]: выбор модуля операций с плавающей точкой. «00» = no FPU; «01» = GRFPU; «10» =
                Meiko FPU, «11» = GRFPU-Lite
       [9]:     Если произведены соответствующие установки, то доступна для использования
                опционная команда умножения с накоплением (МАС).
       [8]:     Если произведены соответствующие установки, то доступна для использования
                команда умножения SPARC V8.
       [7:5]:   количество выполнимых точек контроля (0-4).
       [4:0]:   количество выполнимых регистровых окон, равнозначно NWIN+1.


      3) Регистр ASR18 (значение регистра младшей части (разряды 31:0) сумматора для команды UMAC %asr18) 
      Команда UMAC производит умножение без знака 16-битного операнда с 32-битным результатом, который также
      суммируется, и в 40-битном сумматоре, который, в свою очередь, состоит из %y регистра
      младших 8 битов и %asr18 регистра.

   ----------------------------------------------------------------------

*/
#define ASR16 16
#define ASR17 17
#define ASR18 18

/* Маски для настройки FPU и IU регистров в ASR16*/
#define HamcodeInFPU 0x80000000
#define HamcodeInIU 0x8000

/* Константы адресов для регистров, связанных с SPR */
#define REGISTER_Y_ADDRESS 0x90400000
#define REGISTER_FSR_ADDRESS 0x90400018
#define REGISTER_ASR16_ADDRESS 0x90400040
#define REGISTER_ASR17_ADDRESS 0x90400044
#define REGISTER_ASR18_ADDRESS 0x90400048
#define INCORRECT_REGISTER_ADDRESS 0xDEADDEAD



/* ---------------------- Interupt Registers ---------------------------- */
unsigned int *const r_ITP = (unsigned int *)0x80000204; //r/w, Interrupt Pending Register 
unsigned int *const r_ITC = (unsigned int *)0x8000020C; //w, Interrupt Clear Register

/* ----------------------- AHB Registers ------------------------------- */
unsigned int *const r_StatusAHB = (unsigned int *)0x80000F00; //r/w, AHB Status register
unsigned int *const r_Failar = (unsigned int *)0x80000F04; //r/ , AHB Failing address register


unsigned int *const r_RAO = (unsigned int *)0x20500530; //r,   РАО, Регистр адреса одиночной ошибки
unsigned int *const r_RSO = (unsigned int *)0x20500534; //r/w, РCO, Регистр счетчика одиночных ошибок
unsigned int *const r_RAD = (unsigned int *)0x20500538; //r,   РАД, Регистр адреса двойной ошибки
unsigned int *const r_RSD = (unsigned int *)0x2050053C; //r/w, РСД, Регистр счетчика двойных ошибок
unsigned int *const r_RUE = (unsigned int *)0x20500540; //r/w, РУЕ, Регистр управления EDAC

/* ----------------- Константы кэша процессора ------------------------  */
#define ICACHE_SIZE 0x2000 // Размер кэша команд (8 Кб)
#define DCACHE_SIZE 0x2000 // Размер кэшан данных (8 Кб)
#define ILINE_SIZE 16 // Размер линии кэша команд (16 байт)
#define DLINE_SIZE 16 // Размер линии кэша данных (16 байт)


void MUS_BSP_SetASI(int asi, int data);
int MUS_BSP_GetASI(int asi);

/* 
   ----------------------------------------------------------------------
    Функция SetASR
    Записать значение в необходимый регистр ASR
   ----------------------------------------------------------------------
*/
void MUS_BSP_SetASR(int asrNum, int data);

/* 
   ----------------------------------------------------------------------
    Функция GetASR
    Считать значение необходимого регистра ASR
   ----------------------------------------------------------------------
*/
int MUS_BSP_GetASR(int asrNum);

/*
   ----------------------------------------------------------------------
    Функция ЧИТАТЬ РПТМ  
    Назначение.  
        Для чтения регистра РПТМ.  
    Вход.  
        Регистр РПТМ.  
    Выход.  
        Результат функции - значащая часть регистра РПТМ.  
    Действия.  
        Читает значение регистр РПТМ, накладывает на него маску значащих 
        битов РПТМ, возвращает полученное значение пользователю.  
    Условия.
        Должна работать с запретом прерываний.
        Использует регистр РПТМ. 
    Обращение.
   ----------------------------------------------------------------------
*/
int MUS_BSP_GetRPTM();

/*
   ----------------------------------------------------------------------
    Функция ЗАПИСАТЬ РПТМ  
    Назначение.  
        Для записи в регистр РПТМ.  
    Вход.  
        Параметр: 
        - записываемое значение в регистр РПМТ.
    Выход.  
        Обновлённое значение значащих битов регистра РПТМ.  
    Действия.  
        Записывает в значащие биты регистры РПТМ соответствующие биты из 
        значения указанного пользователем. 
    Условия.
        Должна работать с запретом прерываний.
        Использует регистр РПТМ. 
    Обращение.
   ----------------------------------------------------------------------
*/
void MUS_BSP_SetRPTM(int reg);

/*
   --------------------------------------------------------------------
    Системная функция ЧИТАТЬ РСН
    Чтение текущего значения заданного регистра специального назначения 
    процессора.
   --------------------------------------------------------------------*)
*/
int MUS_BSP_GetSPR(int aReg);

/* 
   ----------------------------------------------------------------------
    Функция Set_r_RGU
    Записать значение в регистр РГУ, Регистр управления
   ----------------------------------------------------------------------
*/
void MUS_BSP_Set_r_RGU(int data);

/* 
   ----------------------------------------------------------------------
    Функция Get_r_RGU
    Считать значение регистр РГУ, Регистр управления
   ----------------------------------------------------------------------
*/
int MUS_BSP_Get_r_RGU();

/* 
   ----------------------------------------------------------------------
    Функция Set_r_BUK
    Записать значение в регистр РБУК, Регистр блокировки управления коммутаторами
   ----------------------------------------------------------------------
*/
void MUS_BSP_Set_r_BUK(int data);

/* 
   ----------------------------------------------------------------------
    Функция Get_r_BUK
    Считать значение регистра РБУК, Регистр блокировки управления коммутаторами
   ----------------------------------------------------------------------
*/
int MUS_BSP_Get_r_BUK(); 

/* 
   ----------------------------------------------------------------------
    Функция Set_r_UKMVP1
    Записать значение в регистр РУК_МВП1,Регистр управления коммутатором МВП1
   ----------------------------------------------------------------------
*/
void MUS_BSP_Set_r_UKMVP1(int data);

/* 
   ----------------------------------------------------------------------
    Функция Get_r_UKMVP1
    Считать значение регистра РУК_МВП1,Регистр управления коммутатором МВП1
   ----------------------------------------------------------------------
*/
int MUS_BSP_Get_r_UKMVP1();

/* 
   ----------------------------------------------------------------------
    Функция Set_r_UKMVP2
    Записать значение в регистр РУК_МВП2,Регистр управления коммутатором МВП2
   ----------------------------------------------------------------------
*/
void MUS_BSP_Set_r_UKMVP2(int data);

/* 
   ----------------------------------------------------------------------
    Функция Get_r_UKMVP2
    Считать значение регистра РУК_МВП2, Регистр управления коммутатором МВП2
   ----------------------------------------------------------------------
*/
int MUS_BSP_Get_r_UKMVP2();


/* ------------------ Контроллер прерываний ОК -------------------------- */
unsigned int *const r_RM1 = (unsigned int *)0x20500000; // r  , РМ1,  Чтение регистра маски РМ1
unsigned int *const r_RM2 = (unsigned int *)0x20500004; // r  , РМ2,  Чтение регистра маски РМ2
unsigned int *const r_RM3 = (unsigned int *)0x20500008; // r  , РМ3,  Чтение регистра маски РМ3

unsigned int *const r_Write0RM1 = (unsigned int *)0x20500010; // w, Зп0РМ1, Запись 0 в регистр маски РМ1
unsigned int *const r_Write0RM2 = (unsigned int *)0x20500014; // w, Зп0РМ2, Запись 0 в регистр маски РМ2
unsigned int *const r_Write0RM3 = (unsigned int *)0x20500018; // w, Зп0РМ3, Запись 0 в регистр маски РМ3

unsigned int *const r_Write1RM1 = (unsigned int *)0x20500020; // w, Зп1РМ1, Запись 1 в регистр маски РМ1
unsigned int *const r_Write1RM2 = (unsigned int *)0x20500024; // w, Зп1РМ2, Запись 1 в регистр маски РМ2
unsigned int *const r_Write1RM3 = (unsigned int *)0x20500028; // w, Зп1РМ1, Запись 1 в регистр маски РМ3

unsigned int *const r_RZC1 = (unsigned int *)0x20500030; //r  , РЗС1, Чтение регистра запросов 1 со сбросом всех заявок
unsigned int *const r_RZC2 = (unsigned int *)0x20500034; //r  , РЗС2, Чтение регистра запросов 2 со сбросом всех заявок
unsigned int *const r_RZC3 = (unsigned int *)0x20500038; //r  , РЗС3, Чтение регистра запросов 3 со сбросом всех заявок 

unsigned int *const r_RZ1 = (unsigned int *)0x20500040; //r  , РЗ1,  Чтение регистра запросов 1 без сброса заявок
unsigned int *const r_RZ2 = (unsigned int *)0x20500044; //r  , РЗ2,  Чтение регистра запросов 2 без сброса заявок
unsigned int *const r_RZ3 = (unsigned int *)0x20500048; //r  , РЗ3,  Чтение регистра запросов 3 без сброса заявок



/* условный номер "регистра" маски\запроса прерываний */
typedef enum {
    irq,
    int1,
    int2,
    int3,
} TNomRegInt;

/* Маска значащих битов регистров КПр ЦП */
#define m_ITM_0 0x0000FFFE // биты регистра маски прерываний процессора
#define m_RZ1 0x333C303C // биты запросов прерываний регистра RZ1
#define m_RZ2 0xFFC3FFF8 // биты запросов прерываний регистра RZ2
#define m_RZ3 0x04E67990 // биты запросов прерываний регистра RZ3

/*
   --------------------------------------------------------------------    
    Функция ЧИТАТЬ РЕГИСТР МАСКИ ПРЕРЫВАНИЙ
    Считать значение регистра маски контроллера прерываний ОК.
   --------------------------------------------------------------------
*/
int MUS_BSP_getRegIntMaska(
    TNomRegInt nReg // Номер регистра маски
); // Возвращаемое значение маски - 32 бита (4 байт)

/*
   --------------------------------------------------------------------    
    Функция УСТАНОВИТЬ РЕГИСТР МАСКИ ПРЕРЫВАНИЙ
    Записать значение в регистр маски контроллера прерываний ОК. 
   --------------------------------------------------------------------
*/
void MUS_BSP_setRegIntMaska(
    TNomRegInt nReg, // Номер регистра маски
    int maska // Устанавливаемое значение регистра маски
);

/*
   --------------------------------------------------------------------    
   Функция ЧИТАТЬ РЕГИСТР ЗАПРОСА ПРЕРЫВАНИЯ
       Считать значение регистра запросов контроллера прерываний ОК.
   --------------------------------------------------------------------
*/
int MUS_BSP_getReqInt(
    TNomRegInt nReg // Номер регистра маски
); // Возвращаемое значение регистра запросов - 32 бита (4 байт)

/*
   --------------------------------------------------------------------
   Функция ОЧИСТИТЬ РЕГИСТР ЗАПРОСА ПРЕРЫВАНИЯ
       Считать значение регистра запросов контроллера прерываний ОК со 
       сбросом всех заявок.
   --------------------------------------------------------------------
*/
int MUS_BSP_getClearReqInt(
    TNomRegInt nReg // Номер регистра маски
); // Возвращаемое значение регистра запросов - 32 бита (4 байт)


/* Переменные для MUS_drvSV */
#define TimeOverflow 0x100000000LL // 2^32 - интервал в мс  между двумя очередными сигналами "переполнение СТВ1"
typedef enum {
    timer1,
    timer2,
    timer3,
    timer4,
    timer5
} nomTimer; // номер таймера (Всего 5 таймеров)

uint64_t STV = 0LL; // снятое в последний раз значение СТВ
#define m_TIMCTR 0x0000001F // SET32 {4, 3, 2, 1, 0} значащие биты регистров управления таймерами 
                            // Закрыты Chain - не исп., Debug Halt - Rd-Only
#define IRQ_OverflowTime32 28 // бит переполнения счётчика СТВ1 в регистре РЗ1
#define IRQ_CompareTime32 29 // номер элемента запроса прерывания 
                             // "Сравнение счетчика СТВ1 с РУСТ1" в регистре РЗ1
#define EN 0 // бит EN регистра TIMCTR
#define RS 1 // бит RS регистра TIMCTR
#define LD 2 // бит LD регистра TIMCTR
#define IE 3 // бит IE регистра TIMCTR 
#define IP 4 // бит IP регистра TIMCTR

#define iT1 8 // номер прерывания от таймера 1 в регистре ITC процессора
#define iT2 9 // номер прерывания от таймера 2 в регистре ITC процессора
#define iT3 10 // номер прерывания от таймера 3 в регистре ITC процессора
#define iT4 11 // номер прерывания от таймера 4 в регистре ITC процессора
#define iT5 12 // номер прерывания от таймера 5 в регистре ITC процессора

/* Желаемое значение тика таймера в секундах */
#define RequiredTimerTick 0.000001 // 1 мкс

#define n_Timer 2 // номер таймера на котором организуем задержку 

/* ------------------ Контроллер времени -------------------------- */
unsigned int *const r_RSTV1 = (unsigned int *)0x20500300; //r/w, СТВ1,  Счетчик текущего времени 1
unsigned int *const r_RSTT = (unsigned int *)0x20500304; //r/w, СТТ2,  Сторожевой таймер в ОК (СТТ)

unsigned int *const r_RUST1 = (unsigned int *)0x20500310; //r/w, РУСТ1, Регистр уставки для СТВ1
unsigned int *const r_RUSSTT = (unsigned int *)0x20500314; //r/w, РХУСТ, Регистр хранения уставки для СТТ

unsigned int *const r_BlSTT = (unsigned int *)0x20500320; //w, БлСТТ, Регистр программной блокировки сравнения СТТ

/* ------------------ Timer Registers -------------------------- */
unsigned int *const r_TIMC1 = (unsigned int *)0x80000310; //r/w, Timer 1 Counter value Register
unsigned int *const r_TIMR1 = (unsigned int *)0x80000314; //r/w, Timer 1 Reload value Register
unsigned int *const r_TIMCTR1 = (unsigned int *)0x80000318; //r/w, Timer 1 Control Register

unsigned int *const r_TIMC2 = (unsigned int *)0x80000320; //r/w, Timer 2 Counter value Register
unsigned int *const r_TIMR2 = (unsigned int *)0x80000324; //r/w, Timer 2 Reload value Register
unsigned int *const r_TIMCTR2 = (unsigned int *)0x80000328; //r/w, Timer 2 Control Register

unsigned int *const r_TIMC3 = (unsigned int *)0x80000330; //r/w, Timer 3 Counter value Register
unsigned int *const r_TIMR3 = (unsigned int *)0x80000334; //r/w, Timer 3 Reload value Register
unsigned int *const r_TIMCTR3 = (unsigned int *)0x80000338; //r/w, Timer 3 Control Register

unsigned int *const r_TIMC4 = (unsigned int *)0x80000340; //r/w, Timer 4 Counter value Register
unsigned int *const r_TIMR4 = (unsigned int *)0x80000344; //r/w, Timer 4 Reload value Register
unsigned int *const r_TIMCTR4 = (unsigned int *)0x80000348; //r/w, Timer 4 Control Register

unsigned int *const r_TIMC5 = (unsigned int *)0x80000350; //r/w, Timer 5 Counter value Register
unsigned int *const r_TIMR5 = (unsigned int *)0x80000354; //r/w, Timer 5 Reload value Register
unsigned int *const r_TIMCTR5 = (unsigned int *)0x80000358; //r/w, Timer 5 Control Register

/*
   --------------------------------------------------------------------
    Функция ЧИТАТЬ СТВ  
        Считать счетчик текущего времени (СТВ).
   --------------------------------------------------------------------
*/
uint64_t MUS_BSP_getSTV();

/*
   --------------------------------------------------------------------
    Функция ЗАПИСАТЬ СТВ
        Установить значение счетчика текущего времени.
   --------------------------------------------------------------------
*/
void MUS_BSP_setSTV(
    uint64_t time // устанавливаемое значение СТВ
);

/*
   --------------------------------------------------------------------
    Функция ЗАПИСАТЬ УСТАВКУ
        Установить значение регистра уставки СТВ.
   --------------------------------------------------------------------
*/
void MUS_BSP_setUst(
    int64_t time // станавливаемое значение регистра уставки СТВ
);

/*
   --------------------------------------------------------------------
    Функция СБРОСИТЬ СТТ
        Сбросить сторожевой таймер (СТТ).
   --------------------------------------------------------------------
*/
void MUS_BSP_resetSTT();

/*
   --------------------------------------------------------------------
    Функция ЧИТАТЬ СТТ
        Считать значение уставки сторожевого таймера.
   --------------------------------------------------------------------
*/
int MUS_BSP_getSTT();

/*
   --------------------------------------------------------------------
    Функция УСТАНОВИТЬ СТТ
        Установить значение уставки сторожевого таймера.
   --------------------------------------------------------------------
*/
void MUS_BSP_setSTT(
    int time // устанавливаемое значение регистра уставки СТТ 
);

/*
   --------------------------------------------------------------------
    Функция БЛОКИРОВАТЬ СТТ
        Блокировка работы сторожевого таймера.
   --------------------------------------------------------------------
*/
void MUS_BSP_blockSTT();

/*
   --------------------------------------------------------------------  
    Функция ЧИТАТЬ RT ТАЙМЕР  
        Считать таймер контроля времени выполнения задач (RT таймера).
   --------------------------------------------------------------------
*/
unsigned int MUS_BSP_getRT();

/*
   --------------------------------------------------------------------
    Функция ЗАПИСАТЬ RT ТАЙМЕР
        Установить значение таймера контроля времени выполнения задач 
        с его запуском и сбросом запроса на прерывание.
   --------------------------------------------------------------------
*/
void MUS_BSP_setRT(
    unsigned int time // устанавливаемое значение RT таймера в мкс
);

/*
   --------------------------------------------------------------------
    Функция ЧИТАТЬ ТАЙМЕР ПРОЦЕССОРА
        Считать значение счетчика указанного таймера.
   --------------------------------------------------------------------
*/
unsigned int MUS_BSP_getTimer(
    nomTimer nTimer // номер таймера процессора
);

/*
   --------------------------------------------------------------------
    Функция ПИСАТЬ ТАЙМЕР ПРОЦЕССОРА
        Установить значение счетчика указанного таймера с запуском таймера 
        и сбросом запроса на прерывание. 
   --------------------------------------------------------------------
*/
void MUS_BSP_setTimer(
    nomTimer nTimer, // номер таймера процессора
    unsigned int time // устанавливаемое значение счетчика таймера в мкс
);

/*
   --------------------------------------------------------------------
    Функция УСТАНОВИТЬ ПЕРЕЗАГРУЗКУ ТАЙМЕРА
        Установить значение перезагрузки и счетчика указанного таймера 
        с запуском таймера и включением режима его автоматической 
        перезагрузки и перезапуска.
   --------------------------------------------------------------------
*/
void MUS_BSP_setTimerReload(
    nomTimer nTimer, // номер таймера процессора
    unsigned int reload // устанавливаемое значение перезагрузки (и счетчика) таймера в мкс 
);

/*
   --------------------------------------------------------------------
    Функция УПРАВЛЕНИЕ ТАЙМЕРОМ ПРОЦЕССОРА
        Установить значение регистра управления указанного таймера.
   --------------------------------------------------------------------
*/
void MUS_BSP_setTimerCtrl(
    nomTimer nTimer, // номер таймера процессора
    unsigned int contrl // устанавливаемое значение регистра управления таймера
);

#endif